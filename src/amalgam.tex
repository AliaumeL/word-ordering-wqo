\section{Infixes and Amalgamation Systems}
\label{infixes-amalgamation:sec}

\AP In the previous section, we have represented languages that are
\kl{downwards closed} by the \kl{infix relation} as \kl{infixes} of infinite
words. However, there are many other natural ways to represent languages, such
as finite automata or context-free grammars. In this section, we are going to
show that our results on \kl{bounded languages} can be applied to a large class
of systems, called \kl{amalgamation systems}, that includes as particular
examples finite automata and context-free grammars. 

\AP Our first result, of theoretical nature, is that \kl{amalgamation systems}
cannot define \kl{well-quasi-ordered} languages that are not
\kl(language){bounded}. This implies that all the results of
\cref{infixes-bounded:sec}, and in particular \cref{bounded-language:thm}, can
safely be applied to \kl{amalgamation systems}.

\begin{theorem}
    \label{infix-amalgamation:thm}
    \proofref{infix-amalgamation:thm}
    Let $L \subseteq \Sigma^*$ be a language recognized by an 
    \kl{amalgamation system}.
    If $L$ is \kl{well-quasi-ordered} by the \kl{infix relation} then $L$ is
    \kl(language){bounded}.
\end{theorem}

\AP Our second focus is of practical nature: we want to give a decision
procedure for being \kl{well-quasi-ordered}. This will require us to introduce
\emph{effectiveness assumptions} on the \kl{amalgamation systems}. While most
of them will be innocuous, an important consequence is that we have to consider
\emph{classes of languages} rather than individual ones, for instance: the
class of all regular language, or the class of all context-free languages. Such
classes will be called \kl(amalgamation)[effectiveness assumptions]{effective
amalgamative classes} (\kcref{effective amalgamation system}). In the
following theorem, we prove that under such assumptions, testing
\kl{well-quasi-ordering} is inter-reducible to testing whether a language of
the class is empty, which is usually the simplest problem for a computational
model.

\begin{theorem}
	\label{infix-wqo-is-emptiness:thm}
	Let $\mathcal{C}$ be an \kl{effective amalgamative class} of languages.
    Then the following are equivalent:
	\begin{enumerate}
        \item\label{wqo-infix-decidable} \kl[wqo]{Well-quasi-orderedness} of the \kl{infix relation} is decidable for languages in $\mathcal{C}$.
        \item\label{wqo-prefix-decidable} \kl[wqo]{Well-quasi-orderedness} of the \kl{prefix relation} is decidable for languages in $\mathcal{C}$.
        \item\label{emptiness-decidable} Emptiness is decidable for languages in $\mathcal{C}$.
	\end{enumerate}
\end{theorem}

%\AP We say that a \kl{strongly effective amalgamative class} is an
%\kl{effective amalgamative class} for which the emptiness problem is decidable.
%Let us immediately remark that the class of \kl{regular languages} is
%\kl(amalg){strongly effective}, and so is the class of context-free languages.
%Therefore, \cref{infix-wqo-is-emptiness:thm} provides a concrete decision
%procedure for these classes.

\subsection{Amalgamation Systems}
\label{amalgamation-systems:subsec}

Let us now formally introduce the notion of \kl{amalgamation systems}, and
recall some results from \cite{ASZZ24} that will be useful for the proof of
\cref{infix-amalgamation:thm}. The notion of \kl{amalgamation system} is
tailored to produce \emph{pumping arguments}, which is exactly what our
\cref{pumping-periods:lem} talks about. At the core of a pumping argument,
there is a notion of a \emph{run}, which could for instance be a sequence of
transitions taken in a finite state automaton. Continuing on the analogy with
finite automata, there is a natural ordering between runs, i.e., a run is
smaller than another one if one can ``delete'' loops of the larger run to obtain
the other. Typical pumping arguments then rely on the fact that
\emph{minimal} runs are of finite size, and that all other runs are
obtained by ``gluing'' loops to minimal runs. Generalizing this notion yields the 
notion of \kl{amalgamation systems}.

\AP Let us recall that over an alphabet $(\Sigma, =)$ a \kl{subword embedding}
between two words $u \in \Sigma^*$ and $v \in \Sigma^*$ is a function $\rho
\colon \range{\card{u}} \to \range{\card{v}}$ such that $u_i = v_{\rho(i)}$ for
all $i \in \range{\card{u}}$. We write $\intro*\HigEmb(u,v)$ the set of all
\kl{subword embeddings} between $u$ and $v$. It may be useful to notice that
the set of finite words over $\Sigma$ forms a category when we consider
\kl{subword embeddings} as morphisms, which is a fancy way to state that
$\mathrm{id} \in \HigEmb(u,u)$ and that $f \circ g \in \HigEmb(u,w)$ whenever
$g \in \HigEmb(u,v)$ and $f \in \HigEmb(v,w)$, for any choice of words
$u,v,w \in \Sigma^*$.

\AP Given a \kl{subword embedding} $f \colon u \to v$ between two words $u$ and
$v$, there exists a unique decomposition $v = \GapWord{f}{0} u_1 \GapWord{f}{1}
\cdots \GapWord{f}{k-1} u_k \GapWord{f}{k}$ where $\GapWord{f}{i} =
v_{f(i)+1} \cdots v_{f(i+1)-1}$ for all $1 \leq i \leq k-1$, $\GapWord{f}{k} =
v_{[f(k)+1} \cdots v_{\card v}$, and $\GapWord{f}{0}   = v_1 \cdots v_{f(1)-1}$. We say that
$\intro*\GapWord{f}{i}$ is the $i$-th \intro{gap word} of $f$. We encourage the
reader to look at \cref{gap-word-embedding:fig} to see an example of the
\kl{gap words} resulting from a \kl{subword embedding} between two words. These
\kl{gap words} will be useful to describe how and where runs of a system
(described by words) can be combined.


\begin{definition}
    An \intro{amalgamation system}
    is a tuple $(\Sigma, R, \canrun, E)$ where
    $\Sigma$ is a finite alphabet,
    $R$ is a set of so-called \emph{runs},
    $\canrun \colon R \to (\Sigma \uplus \set{\cansep})^*$ is a 
    function computing a \intro{canonical decomposition} of a run,
    and $E$ describes the so-called \intro{admissible embeddings} between runs: If $\rho$ and $\sigma$ are runs from $R$, then $E(\rho, \sigma)$ is a subset of the subword embeddings between $\canrun(\rho)$ and $\canrun(\sigma)$. We write $\rho \intro*\runleq \sigma$ if $E(\rho, \sigma)$ is non-empty. If we want to refer to a specific embedding $f \in E(\rho, \sigma)$, we also write $\rho \runleq_f \sigma$.
    Given a run $r \in R$, and $i \in \range[0]{\card{\canrun(r)}}$, 
    the \intro{gap language} of $r$ at position $i$ is $\intro*\GapLanguage{r}{i} \defined
    \setof{\GapWord{f}{i}}{\exists s \in R. \exists f \in E(r,s) }$.
    An \kl{amalgamation system} furthermore satisfies the following 
    properties:
    \begin{enumerate}
        \item \emph{$(R, E)$ Forms a Category.}
            For all $\rho, \sigma, \tau \in R$,
            $\mathrm{id} \in E(\rho,\rho)$,
            and whenever $f \in E(\rho,\sigma)$ and $g \in E(\sigma,\tau)$,
            then $g \circ f \in E(\rho,\tau)$.
        \item \emph{Well-Quasi-Ordered System.}
            $(R, \runleq)$ is a well-quasi-ordered set.
        \item \emph{Concatenative Amalgamation.}
            Let $\rho_0, \rho_1, \rho_2$ be runs 
            with $\rho_0 \runleq_f \rho_1$ 
            and $\rho_0 \runleq_g \rho_2$.
            Then for all $0 \leq i \leq \card{\canrun(\rho_0)}$,
            there exists a run $\rho_3 \in R$ 
            and embeddings $\rho_1 \runleq_{g'} \rho_3$
            and $\rho_2 \runleq_{f'} \rho_3$ 
            satisfying two conditions:
            (a) $g' \circ f = f' \circ g$ (we write $h$ for this composition) and
            (b) for every $0 \leq j \leq \card{\canrun[\rho_0]}$, 
            the gap word $\GapWord{h}{j}$
            is either $\GapWord{f}{j} \GapWord{g}{j}$
            or $\GapWord{h}{j} = \GapWord{g}{j} \GapWord{f}{j}$. 
            Specifically, for $i$ we may fix $\GapWord{h}{i} = \GapWord{f}{i} \GapWord{g}{i}$.
            We refer to \cref{amalgamation-runs:fig} for an illustration 
            of this property.
    \end{enumerate}

	The \emph{yield} of a run is obtained by projecting away the separator symbol \cansep~from the canonical decomposition, i.e. $\intro*\yieldrun(\rho) = \project_\Sigma( \canrun[\rho])$. The language recognized by an \kl{amalgamation system} is $\yieldrun(R)$.
    
    We say a language $L$ is an \intro{amalgamation language} 
    if there exists an \kl{amalgamation system} recognizing it. 
\end{definition}

Intuitively, the definition of an amalgamation system allows the comparison of
runs, and the proper ``gluing'' of runs together to obtain new runs. A number
of well-known language classes can be seen to be recognized by \kl{amalgamation
systems}, e.g., regular languages \cite[Theorem 5.3]{ASZZ24}, reachability and
coverability languages of VASS \cite[Theorem 5.5]{ASZZ24}, and context-free
languages \cite[Theorem 5.10]{ASZZ24}. 

%\subsection{$\infleq$-Well-Quasi-Ordered Amalgamation Systems}

We can now show a simple lemma that illuminates much of the structure of
amalgamation systems whose language is well-quasi-ordered by $\infleq$. Note
that \cref{gap-words-prefix-ordered:lem} uses \cref{pumping-periods:lem} in its
proof, and our \cref{infix-amalgamation:thm} follows from it.

\begin{lemma}
	\label{gap-words-prefix-ordered:lem}
  \proofref{gap-words-prefix-ordered:lem}
	Let $L$ by an \kl{amalgamation language} recognized by $(\Sigma, R, E, \canrun)$ that is well-quasi-ordered by $\infleq$. Let $\rho$ be a run with $\canrun[\rho] = a_1 \cdots a_n$, and let $\sigma, \tau$ be runs with $\rho \runleq_f \sigma$ and $\rho \runleq_g \sigma$. 
	
	For any $0 \leq \ell \leq n$, we have $\GapWord{f}{\ell} \infleq \GapWord{g}{\ell}$ or vice versa.
\end{lemma}



If we additionally assume that such a language is closed under infixes, we
obtain an even stronger structure: All such languages are regular!

\begin{lemma}
    \label{dwclosed-infixes-wqo:lem}
    \proofref{dwclosed-infixes-wqo:lem}
    Let $L \subseteq \Sigma^*$ be a \kl{downwards closed} language for the
    \kl{infix relation} that is \kl{well-quasi-ordered}. Then, the following
    are equivalent:
    {\renewcommand{\theenumi}{\roman{enumi}}
     \renewcommand{\labelenumi}{(\theenumi)}
    \begin{enumerate}
        \item\label{dwci-reg:item} $L$ is a \kl{regular language},
        \item\label{dwci-aml:item} $L$ is recognized by \emph{some} \kl{amalgamation system},
        \item\label{dwci-bod:item} $L$ is a \kl{bounded language},
        \item\label{dwci-uoc:item} There exists 
            a finite set $E \subseteq (\Sigma^*)^3$
            such that $L = \bigcup_{(x,u,y) \in E} \InfPeriodChain{x} u \InfPeriodChain{y}$.
    \end{enumerate}
    }
\end{lemma}

\AP Combining \cref{thue-morse:lemma,dwclosed-infixes-wqo:lem}, we can conclude
that the collection of \kl{infixes} of the \kl{Thue-Morse sequence} cannot be
recognized by \emph{any} \kl{amalgamation system}. 


%\subsection{Effective Decision Procedures}
%\label{infixes-amalgamation-effective:subsec}

\AP To construct a decision procedure for well-quasi-orderedness under
$\infleq$, we our \kl{amalgamation systems} to satisfy certain
\intro(amalgamation){effectiveness assumptions}. We require that for an
\kl{amalgamation system} $(\Sigma, R, E, \canrun)$, $R$ is recursively
enumerable, the function $\canrun(\cdot)$ is computable, and for any two runs
$\rho, \sigma \in R$, the set $E(\rho,\sigma)$ is computable. Additionally, we
require the class to be effectively closed under rational transductions
\cite[Chapter 5, page 64]{BERST79}.

%\AP We say that a class $\mathcal{C}$ of languages is an \intro{effective
%amalgamative class} whenever for every $L \in \mathcal{C}$, there exists an
%effective \kl{amalgamation system} recognizing $L$, and such that $\mathcal{C}$
%is \kl{effectively closed under rational transductions}. Recall that a
%\intro{rational transduction} is a \emph{relation} $R \subseteq \Sigma^* \times
%\Gamma^*$ that can be defined by a (nondeterministic) finite automaton with
%output \cite[Chapter 5, page 64]{BERST79}. A class of languages $\mathcal{C}$
%is \intro{effectively closed under rational transductions} when, for every
%language $L \in \mathcal{C}$, and every rational transduction $R \subseteq
%\Sigma^* \times \Gamma^*$, the image of $L$ through $R$ --- that is, $\setof{v
%\in \Gamma^*}{\exists u \in L. (u,v) \in R}$ --- is in $\mathcal{C}$ and
%effectively computable. In particular, it implies that the class contains
%languages over arbitrary (finite) alphabets.

%\AP A class $\mathcal{C}$ of languages is \intro(amalg){strongly effective}
%whenever the emptiness problem for languages in $\mathcal{C}$ is decidable.
%This notion is interesting because usual language problems such as boundedness
%or simultaneous boundedness are decidable for \kl{strongly effective
%amalgamative classes}~\cite{ASZZ24}. 


The class $\mathcal{C}_\text{aut}$ of \kl{regular languages} and the class
$\mathcal{C}_{\text{cfg}}$ of context-free languages are examples of
\kl{effective amalgamative classes}, hence the following corollary.

\begin{corollary}
    \label{aut-cfg-infix:cor}
    Let $\mathcal{C} \in \set{ \mathcal{C}_\text{aut}, \mathcal{C}_{\text{cfg}}}$.
    It is decidable whether a language in $\mathcal{C}$ is \kl{well-quasi-ordered}
    by the \kl{infix relation}.
    Furthermore, whenever it is \kl{well-quasi-ordered} by the \kl{infix relation},
    it is a \kl{bounded language}.
\end{corollary}
