#!/usr/bin/env python3
#
# Aliaume Lopez
#
# This script generates figures representing some relation
# between words using Hasse diagrams.
# 

import itertools as it
from functools import cmp_to_key

def repr_word(l):
    return "".join(l)


def test_repr_word():
    assert repr_word("") == ""
    assert repr_word(["a", "b", "a"]) == "aba"
    assert repr_word(()) == ""
    assert repr_word(("a", "b", "a")) == "aba"

def repr_tikz(l):
    if l == "":
        return "epsilon"
    else:
        return l

def test_repr_tikz():
    assert repr_tikz("") == "epsilon"
    assert repr_tikz("aba") == "aba"
    assert repr_tikz("ab") == repr_word("ab")

def repr_math(l):
    if l == "":
        return "$\\varepsilon$" 
    else:
        return l    

def test_repr_math():
    assert repr_math("") == "$\\varepsilon$"
    assert repr_math("aba") == "aba"
    assert repr_math("ab") == repr_word("ab")


def subword(u,v):
    if u == "":
        return True

    if len(u) > len(v):
        return False

    if u[0] == v[0]:
        return subword(u[1:], v[1:]) or subword(u, v[1:])
    else:
        return subword(u, v[1:])


def prefix(u,v):
    return v.startswith(u)

def suffix(u,v):
    return v.endswith(u)

def infix(u,v):
    for i in range(len(v)-len(u)+1):
        if v[i:i+len(u)] == u:
            return True
    return False





def generate_figure(size = 4, relation = subword):
    # We create a "triangle-like" 
    # figure with the empty word Îµ at the bottom
    # and each layer containing all the words of size k
    # on top of eachother, and centered based on their size

    layers = []
    for k in range(size):
        words = list(it.product("ab", repeat=k))
        layers.append(words)
    layers[0] = [""]

    # The "nodes", are then dicts 
    # with { "word": "abab", "x": x, "y": y}      
    nodes = {}
    for i in range(size):
        layer_size = 2**i # =  len(layers[i])
        for j, word in enumerate(layers[i]):
            x = j - layer_size/2
            y = i
            w = repr_word(word)
            nodes[w] = {"word": w,
                           "x": x, 
                           "y": y}

    # Now we create the edges of the Hasse Diagram 
    # based on the relation
    edges = []
    for i in range(size-1):
        for ui in layers[i]:
            for vi in layers[i+1]:
                u = repr_word(ui)
                v = repr_word(vi)
                if relation(u,v):
                    edges.append({ "from": u, "to": v })

    return (nodes, edges)

def antichain_branch_ab(size = 4):
    nodes, edges = generate_figure(size, prefix)
    for n in nodes.values():
        w = n["word"]
        if w.count("a") == len(w):
            n["branch"] = True
        if len(w) > 0 and w.count("a") == len(w) - 1 and w[-1] == "b":
            n["antichain"] = True

    for e in edges:
        u = e["from"]
        v = e["to"]
        if nodes[u].get("branch", False) and nodes[v].get("branch", False):
            e["branchEdge"] = True
        elif nodes[u].get("branch", False) and nodes[v].get("antichain", False):
            e["outEdge"] = True

    return (nodes, edges)


def render_figure_matplotlib(nodes, edges):
    # We render the figure using matplotlib
    import matplotlib.pyplot as plt

    for e in edges:
        u = e["from"]
        v = e["to"]
        plt.plot([nodes[u]["x"], nodes[v]["x"]], [-nodes[u]["y"], -nodes[v]["y"]], 'k-')

    for node in nodes.values():
        plt.text(node["x"], -node["y"], node["word"], fontsize=12, ha='center', va='center')

    plt.gca().invert_yaxis()
    plt.axis('off')
    plt.show()


def render_figure_tikz(nodes, edges, standalone=True):
    # We render the figure using TikZ
    if standalone:
        print(r"""%  This document is generated by `src/word-embeddings-figure.py`
%  Please do not edit it directly as it will be likely overwritten
%  The figure represents a Hasse diagram of a relation between words
%  The words are represented as nodes and the relation as edges
%  The figure is generated using TikZ and can be included in a LaTeX document
%  using the `standalone` class/package.
\documentclass[tikz]{standalone}
\usepackage{tikz}
\begin{document}
\begin{tikzpicture}[
        isWord/.style={rectangle,inner sep=0mm},
        isEmbedding/.style={->, >=stealth, thick},
        branch/.style={A5},
        antichain/.style={A2},
        branchEdge/.style={A5,dashed},
        outEdge/.style={dotted,B2},
        ]

        """)


    for node in nodes.values():
        node["isWord"] = True
        params = ",".join(f"{k}" for (k,v) in node.items() if type(v) == bool and  v == True )
        print(f"\\node[{params}] ({repr_tikz(node['word'])}) at ({node['x']}, {node['y']}) {{\\strut {repr_math(node['word'])}}};")

    for e in edges:
        u = e["from"]
        v = e["to"]
        e["isEmbedding"] = True
        params = ",".join(f"{k}" for (k,v) in e.items() if type(v) == bool and v == True )
        print(f"\\draw[{params}] ({repr_tikz(u)}) -- ({repr_tikz(v)});")

    if standalone:
        print(r"""
\end{tikzpicture}
\end{document}
        """)

if __name__ == "__main__":
    # By default we render the figure using TikZ and printing in the 
    # standard output. We take as arguments
    # --relation = subword|prefix|infix|suffix
    # --size = 4
    # --output = tikz|matplotlib
    import argparse
    parser = argparse.ArgumentParser(description='Generate Hasse Diagrams for words')
    parser.add_argument('--relation', type=str, default="subword", help='The relation to use (subword, prefix, infix, suffix)')
    parser.add_argument('--size', type=int, default=4, help='The maximal size of the words')
    parser.add_argument('--output', type=str, default="tikz", help='The output format (standalone, tikz, matplotlib)')
    parser.add_argument("--antichain", type=bool, default=False, help="Generate an antichain figure")

    args = parser.parse_args()
    if args.antichain:
        nodes, edges = antichain_branch_ab(args.size)
    else:
        nodes, edges = generate_figure(args.size, eval(args.relation))

    if args.output == "matplotlib":
        render_figure_matplotlib(nodes, edges)
    elif args.output == "tikz":
        render_figure_tikz(nodes, edges, standalone=False)
    elif args.output == "standalone":
        render_figure_tikz(nodes, edges, standalone=True)
    else:
        print("Unknown output format")

    


# -- Unit Tests --
def test_subword_empty():
    assert subword("", "")
    assert subword("", "a")
    assert subword("", "aba")
    assert (not subword("a", ""))
    assert (not subword("aba", ""))

def test_subword_infix():
    assert subword("a", "a")
    assert not subword("a", "bbb")
    assert subword("b", "bbb")
    assert subword("a", "bab")

def test_subword_scattered():
    assert subword("ab", "aaabbb")
    assert not subword("ab", "bbbaaa")
    assert subword("aaaa","aaaab")
    assert subword("aaaa","baaaa")


def test_prefix_empty():
    assert prefix("", "")
    assert prefix("", "a")
    assert prefix("", "aba")
    assert not prefix("a", "")
    assert not prefix("aba", "")
